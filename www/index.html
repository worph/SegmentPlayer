<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SegmentPlayer - Media Browser</title>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem;
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }
        h1 {
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }
        h1:hover {
            opacity: 0.8;
        }
        .badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            background: #4dabf7;
            color: #000;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: bold;
        }
        .header-buttons {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }
        .header-btn {
            background: none;
            border: 1px solid #333;
            color: #888;
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            text-decoration: none;
            transition: all 0.2s;
        }
        .header-btn:hover {
            border-color: #4dabf7;
            color: #4dabf7;
        }

        /* ============ BROWSE MODE ============ */
        .browse-view {
            display: block;
        }
        .browse-view.hidden {
            display: none;
        }
        .browse-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        .browse-breadcrumb {
            font-size: 0.9rem;
            color: #888;
        }
        .browse-breadcrumb span {
            cursor: pointer;
            color: #4dabf7;
        }
        .browse-breadcrumb span:hover {
            text-decoration: underline;
        }
        .browse-stats {
            font-size: 0.85rem;
            color: #666;
        }
        .media-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
        }
        .media-card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        .media-card:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(77, 171, 247, 0.3);
            transform: translateY(-2px);
        }
        .media-card.folder {
            background: rgba(255, 212, 59, 0.05);
        }
        .media-card.folder:hover {
            background: rgba(255, 212, 59, 0.1);
            border-color: rgba(255, 212, 59, 0.3);
        }
        .media-card-icon {
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            background: rgba(0,0,0,0.2);
        }
        .media-card.folder .media-card-icon {
            background: rgba(255, 212, 59, 0.1);
        }
        .media-card-info {
            padding: 1rem;
        }
        .media-card-name {
            font-size: 0.95rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .media-card-meta {
            font-size: 0.8rem;
            color: #888;
            display: flex;
            gap: 1rem;
        }

        /* ============ PLAYER MODE ============ */
        .player-view {
            display: none;
        }
        .player-view.active {
            display: block;
        }
        .layout {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 1.5rem;
        }
        @media (max-width: 900px) {
            .layout {
                grid-template-columns: 1fr;
            }
        }

        /* File Browser Sidebar */
        .file-browser {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            overflow: hidden;
        }
        .file-browser-header {
            padding: 1rem;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-weight: 600;
        }
        .file-list {
            max-height: 70vh;
            overflow-y: auto;
        }
        .file-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            transition: background 0.2s;
        }
        .file-item:hover {
            background: rgba(255,255,255,0.1);
        }
        .file-item.active {
            background: rgba(77, 171, 247, 0.2);
            border-left: 3px solid #4dabf7;
        }
        .file-item.folder {
            color: #ffd43b;
        }
        .file-icon {
            font-size: 1.2rem;
        }
        .file-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 0.9rem;
        }
        .file-size {
            color: #888;
            font-size: 0.8rem;
        }
        .sidebar-breadcrumb {
            padding: 0.5rem 1rem;
            background: rgba(0,0,0,0.1);
            font-size: 0.85rem;
            color: #888;
        }
        .sidebar-breadcrumb span {
            cursor: pointer;
            color: #4dabf7;
        }
        .sidebar-breadcrumb span:hover {
            text-decoration: underline;
        }

        /* Player Section */
        .player-section {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .video-container {
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }
        video {
            width: 100%;
            display: block;
            max-height: 60vh;
        }
        .controls {
            padding: 1rem;
            background: #111;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .controls label {
            color: #888;
            font-size: 0.85rem;
        }
        .controls select {
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            border: 1px solid #333;
            background: #222;
            color: #fff;
            font-size: 0.85rem;
            cursor: pointer;
            min-width: 120px;
        }
        .controls select:hover {
            border-color: #555;
        }
        .controls input[type="checkbox"] {
            margin-right: 0.4rem;
            cursor: pointer;
        }
        .controls button {
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            border: 1px solid #333;
            background: #222;
            color: #fff;
            font-size: 0.85rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            transition: all 0.2s;
        }
        .controls button:hover {
            border-color: #4dabf7;
            background: rgba(77, 171, 247, 0.1);
        }
        .controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .status {
            margin-left: auto;
            padding: 0.4rem 0.8rem;
            background: #222;
            border-radius: 6px;
            font-size: 0.8rem;
            color: #4dabf7;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            flex-shrink: 0;
        }
        .status-dot.pulse {
            animation: pulse 1s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        /* Now Playing */
        .now-playing {
            padding: 1rem;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }
        .now-playing-title {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 0.25rem;
        }
        .now-playing-name {
            font-size: 1.1rem;
            font-weight: 500;
            word-break: break-word;
        }

        /* Metrics Panel */
        .metrics-panel {
            padding: 1rem;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            font-size: 0.85rem;
            display: none;
        }
        .metrics-panel.active {
            display: block;
        }
        .metrics-panel h3 {
            color: #22d3ee;
            margin-bottom: 0.75rem;
            font-size: 0.9rem;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 0.75rem;
        }
        .metric-item {
            background: rgba(0,0,0,0.2);
            padding: 0.75rem;
            border-radius: 6px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: #fff;
        }
        .metric-value.good { color: #51cf66; }
        .metric-value.warning { color: #ffd43b; }
        .metric-value.bad { color: #ff6b6b; }
        .metric-label {
            font-size: 0.7rem;
            color: #888;
            margin-top: 0.25rem;
            text-transform: uppercase;
        }

        /* Loading & Empty States */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: #888;
        }
        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid #333;
            border-top-color: #4dabf7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 0.75rem;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: #666;
            text-align: center;
        }
        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 id="homeBtn">
                SegmentPlayer <span class="badge">LIVE</span>
            </h1>
            <div class="header-buttons">
                <button class="header-btn" id="metricsToggle">Metrics</button>
            </div>
        </header>

        <!-- Browse Mode: Full-page media grid -->
        <div class="browse-view" id="browseView">
            <div class="browse-header">
                <div class="browse-breadcrumb" id="browseBreadcrumb"></div>
                <div class="browse-stats" id="browseStats"></div>
            </div>
            <div class="media-grid" id="mediaGrid">
                <div class="loading">
                    <div class="spinner"></div>
                    Loading media...
                </div>
            </div>
        </div>

        <!-- Player Mode: Sidebar + Player -->
        <div class="player-view" id="playerView">
            <div class="layout">
                <!-- File Browser Sidebar -->
                <div class="file-browser">
                    <div class="file-browser-header">Media Files</div>
                    <div class="sidebar-breadcrumb" id="sidebarBreadcrumb"></div>
                    <div class="file-list" id="fileList"></div>
                </div>

                <!-- Player Section -->
                <div class="player-section">
                    <div class="video-container">
                        <video id="video" controls crossorigin="anonymous"></video>
                        <div class="controls">
                            <div class="control-group">
                                <label>Quality:</label>
                                <select id="resolutionSelect" disabled>
                                    <option value="original">Original</option>
                                    <option value="1080p">1080p</option>
                                    <option value="720p">720p</option>
                                    <option value="480p">480p</option>
                                    <option value="360p">360p</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label>Audio:</label>
                                <select id="audioSelect" disabled>
                                    <option value="">Default</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label>Subtitles:</label>
                                <select id="subtitleSelect" disabled>
                                    <option value="">Off</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label>
                                    <input type="checkbox" id="forceTranscode"> Force Transcode
                                </label>
                            </div>
                            <button id="downloadBtn" disabled title="Download original file">
                                <span>Download</span>
                            </button>
                            <span class="status" id="status"><span class="status-dot" id="statusDot"></span><span id="statusText">Select a file</span></span>
                        </div>
                    </div>

                    <div class="now-playing" id="nowPlaying" style="display: none;">
                        <div class="now-playing-title">Now Playing</div>
                        <div class="now-playing-name" id="nowPlayingName"></div>
                    </div>

                    <div class="metrics-panel" id="metricsPanel">
                        <h3>Transcode Performance</h3>
                        <div class="metrics-grid">
                            <div class="metric-item">
                                <div class="metric-value" id="metricRatioAvg">-</div>
                                <div class="metric-label">Avg Ratio</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value" id="metricRatioLast">-</div>
                                <div class="metric-label">Last Ratio</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value" id="metricRatioMin">-</div>
                                <div class="metric-label">Best</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value" id="metricRatioMax">-</div>
                                <div class="metric-label">Worst</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value" id="metricCacheHit">-</div>
                                <div class="metric-label">Cache Hit</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value" id="metricSegments">-</div>
                                <div class="metric-label">Segments</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const video = document.getElementById("video");
        const audioSelect = document.getElementById("audioSelect");
        const subtitleSelect = document.getElementById("subtitleSelect");
        const resolutionSelect = document.getElementById("resolutionSelect");
        const statusEl = document.getElementById("status");
        const statusDot = document.getElementById("statusDot");
        const statusText = document.getElementById("statusText");
        const fileList = document.getElementById("fileList");
        const mediaGrid = document.getElementById("mediaGrid");
        const browseView = document.getElementById("browseView");
        const playerView = document.getElementById("playerView");
        const browseBreadcrumb = document.getElementById("browseBreadcrumb");
        const sidebarBreadcrumb = document.getElementById("sidebarBreadcrumb");
        const browseStats = document.getElementById("browseStats");
        const nowPlaying = document.getElementById("nowPlaying");
        const nowPlayingName = document.getElementById("nowPlayingName");
        const downloadBtn = document.getElementById("downloadBtn");
        const homeBtn = document.getElementById("homeBtn");

        let hls = null;
        let currentPath = "";
        let currentFile = null;
        let currentResolution = "original";
        let isPlayerMode = false;

        // Configuration
        const urlParams = new URLSearchParams(window.location.search);
        const MAX_BUFFER_LENGTH = parseInt(urlParams.get('buffer') || '300');

        // Video/subtitle extensions
        const videoExtensions = [".mp4", ".mkv", ".mov", ".avi", ".webm", ".m4v", ".ts", ".m2ts"];
        const subtitleExtensions = [".vtt", ".srt", ".ass", ".ssa"];

        // Status helper
        function setStatus(text, color, pulsing = false) {
            statusText.textContent = text;
            statusEl.style.color = color;
            statusDot.classList.toggle("pulse", pulsing);
        }

        // Format file size
        function formatSize(bytes) {
            if (bytes === 0) return "0 B";
            const k = 1024;
            const sizes = ["B", "KB", "MB", "GB"];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + " " + sizes[i];
        }

        function isVideo(name) {
            const lower = name.toLowerCase();
            return videoExtensions.some(ext => lower.endsWith(ext));
        }

        function isSubtitle(name) {
            const lower = name.toLowerCase();
            return subtitleExtensions.some(ext => lower.endsWith(ext));
        }

        function getIcon(item) {
            if (item.type === "directory") return "üìÅ";
            if (isVideo(item.name)) return "üé¨";
            if (isSubtitle(item.name)) return "üìù";
            return "üìÑ";
        }

        function encodeFilePath(path) {
            return path.split('/').map(part => encodeURIComponent(part)).join('/');
        }

        // Switch between browse and player modes
        function switchToPlayerMode() {
            if (isPlayerMode) return;
            isPlayerMode = true;
            browseView.classList.add("hidden");
            playerView.classList.add("active");
        }

        function switchToBrowseMode() {
            if (!isPlayerMode) return;
            isPlayerMode = false;
            playerView.classList.remove("active");
            browseView.classList.remove("hidden");

            // Stop video and clear
            if (hls) {
                hls.destroy();
                hls = null;
            }
            video.src = "";
            currentFile = null;

            // Clear URL hash
            history.pushState(null, "", window.location.pathname);

            // Reload browse view with current path
            loadBrowseView(currentPath);
        }

        // Home button
        homeBtn.addEventListener("click", () => {
            if (isPlayerMode) {
                switchToBrowseMode();
            } else {
                currentPath = "";
                loadBrowseView("");
            }
        });

        // Update URL hash when playing
        function updateUrlHash(filePath) {
            const encodedPath = encodeFilePath(filePath);
            history.pushState(null, "", `#/play/${encodedPath}`);
        }

        // Build breadcrumb HTML
        function buildBreadcrumb(path, targetId) {
            const parts = path ? path.split("/") : [];
            let html = '<span data-path="">Home</span>';
            let accumulated = "";

            parts.forEach((part) => {
                accumulated += (accumulated ? "/" : "") + part;
                html += ` / <span data-path="${accumulated}">${part}</span>`;
            });

            const container = document.getElementById(targetId);
            container.innerHTML = html;

            container.querySelectorAll("span").forEach(span => {
                span.addEventListener("click", () => {
                    currentPath = span.dataset.path;
                    if (isPlayerMode) {
                        loadSidebarFiles(currentPath);
                    } else {
                        loadBrowseView(currentPath);
                    }
                });
            });
        }

        // Load browse view (full-page grid)
        async function loadBrowseView(path = "") {
            mediaGrid.innerHTML = '<div class="loading"><div class="spinner"></div>Loading media...</div>';
            buildBreadcrumb(path, "browseBreadcrumb");

            try {
                const response = await fetch("/api/files/" + (path ? path + "/" : ""));
                if (!response.ok) throw new Error("Failed to load files");

                const files = await response.json();

                // Sort: folders first, then by name
                files.sort((a, b) => {
                    if (a.type === "directory" && b.type !== "directory") return -1;
                    if (a.type !== "directory" && b.type === "directory") return 1;
                    return a.name.localeCompare(b.name);
                });

                // Filter to show only videos and folders
                const filtered = files.filter(f => f.type === "directory" || isVideo(f.name));

                // Stats
                const folderCount = filtered.filter(f => f.type === "directory").length;
                const videoCount = filtered.filter(f => f.type !== "directory").length;
                browseStats.textContent = `${folderCount} folders, ${videoCount} videos`;

                if (filtered.length === 0) {
                    mediaGrid.innerHTML = `
                        <div class="empty-state" style="grid-column: 1 / -1;">
                            <div class="empty-state-icon">üìÇ</div>
                            <div>No media files found</div>
                            <div style="font-size: 0.85rem; margin-top: 0.5rem; color: #888;">
                                Add video files to your media folder
                            </div>
                        </div>
                    `;
                    return;
                }

                mediaGrid.innerHTML = filtered.map(file => {
                    const fullPath = path ? path + "/" + file.name : file.name;
                    const isFolder = file.type === "directory";

                    return `
                        <div class="media-card ${isFolder ? 'folder' : ''}"
                             data-path="${fullPath}"
                             data-type="${file.type}"
                             data-name="${file.name}">
                            <div class="media-card-icon">${getIcon(file)}</div>
                            <div class="media-card-info">
                                <div class="media-card-name" title="${file.name}">${file.name}</div>
                                <div class="media-card-meta">
                                    ${isFolder ? '<span>Folder</span>' : `<span>${formatSize(file.size || 0)}</span>`}
                                </div>
                            </div>
                        </div>
                    `;
                }).join("");

                // Add click handlers
                mediaGrid.querySelectorAll(".media-card").forEach(card => {
                    card.addEventListener("click", () => {
                        const cardPath = card.dataset.path;
                        const cardType = card.dataset.type;
                        const cardName = card.dataset.name;

                        if (cardType === "directory") {
                            currentPath = cardPath;
                            loadBrowseView(cardPath);
                        } else if (isVideo(cardName)) {
                            // Switch to player mode and play
                            switchToPlayerMode();
                            loadSidebarFiles(currentPath).then(() => {
                                playFile(cardPath, cardName);
                            });
                        }
                    });
                });

            } catch (err) {
                console.error("Error loading files:", err);
                mediaGrid.innerHTML = `
                    <div class="empty-state" style="grid-column: 1 / -1;">
                        <div class="empty-state-icon">‚ö†Ô∏è</div>
                        <div>Error loading files</div>
                        <div style="font-size: 0.85rem; margin-top: 0.5rem;">${err.message}</div>
                    </div>
                `;
            }
        }

        // Load sidebar files (player mode)
        async function loadSidebarFiles(path = "") {
            fileList.innerHTML = '<div class="loading"><div class="spinner"></div>Loading...</div>';
            buildBreadcrumb(path, "sidebarBreadcrumb");

            try {
                const response = await fetch("/api/files/" + (path ? path + "/" : ""));
                if (!response.ok) throw new Error("Failed to load files");

                const files = await response.json();

                files.sort((a, b) => {
                    if (a.type === "directory" && b.type !== "directory") return -1;
                    if (a.type !== "directory" && b.type === "directory") return 1;
                    return a.name.localeCompare(b.name);
                });

                const filtered = files.filter(f => f.type === "directory" || isVideo(f.name) || isSubtitle(f.name));

                if (filtered.length === 0) {
                    fileList.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üìÇ</div>
                            <div>No media files</div>
                        </div>
                    `;
                    return;
                }

                fileList.innerHTML = filtered.map(file => {
                    const fullPath = path ? path + "/" + file.name : file.name;
                    const isActive = currentFile === fullPath;
                    const isFolder = file.type === "directory";

                    return `
                        <div class="file-item ${isFolder ? 'folder' : ''} ${isActive ? 'active' : ''}"
                             data-path="${fullPath}"
                             data-type="${file.type}"
                             data-name="${file.name}">
                            <span class="file-icon">${getIcon(file)}</span>
                            <span class="file-name">${file.name}</span>
                            ${file.size ? `<span class="file-size">${formatSize(file.size)}</span>` : ''}
                        </div>
                    `;
                }).join("");

                fileList.querySelectorAll(".file-item").forEach(item => {
                    item.addEventListener("click", () => {
                        const itemPath = item.dataset.path;
                        const itemType = item.dataset.type;
                        const itemName = item.dataset.name;

                        if (itemType === "directory") {
                            currentPath = itemPath;
                            loadSidebarFiles(itemPath);
                        } else if (isVideo(itemName)) {
                            playFile(itemPath, itemName);
                        }
                    });
                });

            } catch (err) {
                console.error("Error loading files:", err);
                fileList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ö†Ô∏è</div>
                        <div>Error</div>
                    </div>
                `;
            }
        }

        // Find subtitles for video
        async function findSubtitles(videoPath) {
            const dir = videoPath.substring(0, videoPath.lastIndexOf("/")) || "";
            const videoName = videoPath.substring(videoPath.lastIndexOf("/") + 1);
            const baseName = videoName.substring(0, videoName.lastIndexOf("."));

            try {
                const response = await fetch("/api/files/" + (dir ? dir + "/" : ""));
                if (!response.ok) return [];

                const files = await response.json();
                return files
                    .filter(f => isSubtitle(f.name) && f.name.startsWith(baseName))
                    .map(f => ({
                        name: f.name,
                        path: dir ? dir + "/" + f.name : f.name,
                        lang: extractLang(f.name, baseName)
                    }));
            } catch {
                return [];
            }
        }

        function extractLang(subName, baseName) {
            const withoutBase = subName.substring(baseName.length);
            const match = withoutBase.match(/[._]([a-z]{2,3})/i);
            return match ? match[1].toUpperCase() : "Unknown";
        }

        // Reset metrics
        async function resetMetrics() {
            try {
                await fetch("/transcode/reset-metrics");
            } catch (e) {}
        }

        // Play video file
        async function playFile(filePath, fileName) {
            currentFile = filePath;
            const forceTranscode = document.getElementById("forceTranscode").checked;

            // Update URL hash
            updateUrlHash(filePath);

            resetMetrics();

            // Update sidebar active state
            document.querySelectorAll(".file-item").forEach(item => {
                item.classList.toggle("active", item.dataset.path === filePath);
            });

            nowPlaying.style.display = "block";
            nowPlayingName.textContent = fileName;
            setStatus("Loading...", "#4dabf7", true);

            downloadBtn.disabled = false;
            downloadBtn.title = "Download: " + fileName;

            if (hls) {
                hls.destroy();
                hls = null;
            }

            audioSelect.innerHTML = '<option value="">Loading...</option>';
            audioSelect.disabled = true;
            subtitleSelect.innerHTML = '<option value="">Off</option>';
            subtitleSelect.disabled = true;

            video.querySelectorAll("track").forEach(t => t.remove());

            if (forceTranscode) {
                tryTranscodedFallback(filePath, fileName);
                return;
            }

            const videoSrc = "/hls/" + encodeURIComponent(filePath) + "/master.m3u8";

            if (Hls.isSupported()) {
                hls = new Hls({
                    debug: false,
                    enableWorker: true,
                    lowLatencyMode: false,
                    maxBufferLength: 30,
                    maxMaxBufferLength: 60
                });

                hls.loadSource(videoSrc);
                hls.attachMedia(video);

                hls.on(Hls.Events.MANIFEST_PARSED, async function(event, data) {
                    setStatus("Ready", "#51cf66");

                    if (hls.audioTracks && hls.audioTracks.length > 0) {
                        audioSelect.innerHTML = hls.audioTracks.map((track, i) => {
                            const label = track.name || track.lang || `Track ${i + 1}`;
                            return `<option value="${i}">${label}</option>`;
                        }).join("");
                        audioSelect.disabled = false;
                        audioSelect.value = hls.audioTrack;
                    } else {
                        audioSelect.innerHTML = '<option value="">Default</option>';
                        audioSelect.disabled = true;
                    }

                    const subs = await findSubtitles(filePath);
                    if (subs.length > 0) {
                        subtitleSelect.innerHTML = '<option value="">Off</option>' +
                            subs.map(sub => `<option value="${sub.path}">${sub.lang}</option>`).join("");
                        subtitleSelect.disabled = false;
                    }

                    video.play().catch(() => {});
                });

                hls.on(Hls.Events.ERROR, function(event, data) {
                    if (data.fatal) {
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                tryTranscodedFallback(filePath, fileName);
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                hls.recoverMediaError();
                                break;
                            default:
                                setStatus("Error", "#ff6b6b");
                        }
                    }
                });

                hls.on(Hls.Events.FRAG_LOADED, function() {
                    setStatus("", "#51cf66");
                });

            } else if (video.canPlayType("application/vnd.apple.mpegurl")) {
                video.src = videoSrc;
                video.addEventListener("loadedmetadata", function() {
                    setStatus("Ready", "#51cf66");
                    video.play().catch(() => {});
                });
            } else {
                setStatus("HLS not supported", "#ff6b6b");
            }
        }

        // Audio track change
        audioSelect.addEventListener("change", function() {
            if (hls && this.value !== "") {
                const idx = parseInt(this.value);
                const currentTime = video.currentTime;
                const wasPlaying = !video.paused;

                // Switch audio track
                if (hls.audioTracks && hls.audioTracks.length > idx) {
                    hls.audioTrack = idx;
                }

                // Flush buffer and seek to force immediate audio change
                // With muxed segments, buffered content has old audio baked in
                // Seeking forces reload from new audio stream
                setTimeout(() => {
                    // Small seek forward then back triggers buffer reload
                    video.currentTime = currentTime + 0.1;
                    setTimeout(() => {
                        video.currentTime = currentTime;
                        if (wasPlaying) video.play();
                    }, 50);
                }, 100);
            }
        });

        // Subtitle change
        subtitleSelect.addEventListener("change", function() {
            const val = parseInt(this.value);
            video.querySelectorAll("track").forEach(t => t.remove());
            for (let i = 0; i < video.textTracks.length; i++) {
                video.textTracks[i].mode = "hidden";
            }

            if (val === -1 || this.value === "" || this.value === "-1") return;

            if (hls && hls.subtitleTracks && hls.subtitleTracks.length > 0) {
                hls.subtitleTrack = val;
                return;
            }

            if (currentTranscodeBase && transcodedSubtitleTracks[val]) {
                const vttUrl = currentTranscodeBase + "/subs_" + val + ".vtt";
                const track = document.createElement("track");
                track.kind = "subtitles";
                track.src = vttUrl;
                track.default = true;
                track.label = transcodedSubtitleTracks[val].name;
                video.appendChild(track);
                track.addEventListener("load", function() {
                    if (video.textTracks.length > 0) {
                        video.textTracks[0].mode = "showing";
                    }
                });
                return;
            }

            if (this.value) {
                const track = document.createElement("track");
                track.kind = "subtitles";
                track.src = "/subs/" + this.value;
                track.default = true;
                video.appendChild(track);
                track.addEventListener("load", function() {
                    if (video.textTracks.length > 0) {
                        video.textTracks[0].mode = "showing";
                    }
                });
            }
        });

        // Transcoded fallback
        async function tryTranscodedFallback(filePath, fileName) {
            setStatus("Transcoding...", "#ffd43b", true);

            const transcodedSrc = "/transcode/" + encodeFilePath(filePath) + "/master.m3u8";

            try {
                const response = await fetch(transcodedSrc);
                if (response.ok) {
                    playTranscoded(transcodedSrc, fileName, true);
                } else {
                    setStatus("Error", "#ff6b6b");
                }
            } catch (err) {
                setStatus("Error", "#ff6b6b");
            }
        }

        let currentTranscodeBase = "";
        let transcodedAudioTracks = [];
        let transcodedSubtitleTracks = [];

        function parseAndPopulateTracks(manifest) {
            transcodedAudioTracks = [];
            transcodedSubtitleTracks = [];

            const lines = manifest.split('\n');
            for (const line of lines) {
                // Parse audio tracks from EXT-X-MEDIA declarations
                if (line.startsWith('#EXT-X-MEDIA:TYPE=AUDIO')) {
                    const name = line.match(/NAME="([^"]+)"/)?.[1] || 'Audio';
                    const uri = line.match(/URI="([^"]+)"/)?.[1] || '';
                    transcodedAudioTracks.push({ name, uri });
                }
                // Parse subtitles from EXT-X-MEDIA declarations
                else if (line.startsWith('#EXT-X-MEDIA:TYPE=SUBTITLES')) {
                    const name = line.match(/NAME="([^"]+)"/)?.[1] || 'Subtitle';
                    const uri = line.match(/URI="([^"]+)"/)?.[1] || '';
                    transcodedSubtitleTracks.push({ name, uri });
                }
            }

            if (transcodedAudioTracks.length > 0) {
                audioSelect.innerHTML = transcodedAudioTracks.map((track, i) =>
                    `<option value="${i}">${track.name}</option>`
                ).join("");
                audioSelect.disabled = false;
                audioSelect.value = "0";
            }

            if (transcodedSubtitleTracks.length > 0) {
                subtitleSelect.innerHTML = '<option value="-1">Off</option>' +
                    transcodedSubtitleTracks.map((track, i) =>
                        `<option value="${i}">${track.name}</option>`
                    ).join("");
                subtitleSelect.disabled = false;
            }
        }

        let availableResolutions = [];

        function parseAndPopulateResolutions(manifest) {
            availableResolutions = [];
            const lines = manifest.split('\n');

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.startsWith('#EXT-X-STREAM-INF')) {
                    const resMatch = line.match(/RESOLUTION=(\d+)x(\d+)/);
                    const nextLine = lines[i + 1];
                    if (resMatch && nextLine) {
                        const width = parseInt(resMatch[1]);
                        const height = parseInt(resMatch[2]);
                        const uriMatch = nextLine.match(/stream_a\d+_(\w+)\.m3u8/);
                        if (uriMatch) {
                            const resName = uriMatch[1];
                            availableResolutions.push({
                                name: resName === 'original' ? `Original (${width}x${height})` : `${height}p`,
                                value: resName
                            });
                        }
                    }
                }
            }

            if (availableResolutions.length > 0) {
                resolutionSelect.innerHTML = availableResolutions.map(res =>
                    `<option value="${res.value}">${res.name}</option>`
                ).join("");
                resolutionSelect.value = currentResolution;
            }
        }

        resolutionSelect.addEventListener("change", function() {
            if (!hls || !hls.levels || hls.levels.length === 0) return;

            const newResolution = this.value;
            if (newResolution === currentResolution) return;

            resetMetrics();
            currentResolution = newResolution;

            // Find the level index matching the selected resolution
            // -1 means auto (ABR)
            if (newResolution === 'auto') {
                hls.currentLevel = -1;
            } else {
                const targetHeight = parseInt(newResolution) || 0;
                let levelIdx = -1;

                for (let i = 0; i < hls.levels.length; i++) {
                    const level = hls.levels[i];
                    if (newResolution === 'original' || newResolution === 'source') {
                        // Pick highest quality for "original"
                        if (levelIdx === -1 || level.height > hls.levels[levelIdx].height) {
                            levelIdx = i;
                        }
                    } else if (level.height === targetHeight) {
                        levelIdx = i;
                        break;
                    }
                }

                if (levelIdx >= 0) {
                    hls.currentLevel = levelIdx;
                }
            }
        });

        async function playTranscoded(url, fileName, isLive = false) {
            if (hls) {
                hls.destroy();
            }

            setStatus(isLive ? "Transcoding..." : "Transcoded", "#ffd43b", isLive);

            currentTranscodeBase = url.replace("/master.m3u8", "");

            try {
                const response = await fetch(url);
                const manifest = await response.text();
                parseAndPopulateTracks(manifest);
                parseAndPopulateResolutions(manifest);
            } catch (e) {}

            resolutionSelect.disabled = false;

            hls = new Hls({
                debug: false,
                enableWorker: true,
                maxBufferLength: MAX_BUFFER_LENGTH,
                maxMaxBufferLength: MAX_BUFFER_LENGTH * 2
            });

            // Load the master playlist - HLS.js will handle audio track switching
            hls.loadSource(url);
            hls.attachMedia(video);

            hls.on(Hls.Events.MANIFEST_PARSED, function(event, data) {
                setStatus("", "#51cf66");

                // Populate resolution dropdown from HLS.js levels
                if (hls.levels && hls.levels.length > 0) {
                    const levels = hls.levels.map((level, i) => ({
                        index: i,
                        height: level.height,
                        width: level.width,
                        bitrate: level.bitrate
                    }));

                    // Sort by height descending
                    levels.sort((a, b) => b.height - a.height);

                    // First option is "Original" (highest quality)
                    const originalHeight = levels[0].height;
                    resolutionSelect.innerHTML =
                        `<option value="${originalHeight}">Original (${originalHeight}p)</option>` +
                        '<option value="auto">Auto</option>' +
                        levels.slice(1).map(l => `<option value="${l.height}">${l.height}p</option>`).join("");
                    resolutionSelect.disabled = false;
                    resolutionSelect.value = originalHeight.toString();
                    currentResolution = originalHeight.toString();

                    // Set HLS.js to use the highest quality level
                    const highestLevelIdx = levels[0].index;
                    hls.currentLevel = highestLevelIdx;
                }

                // Populate audio dropdown from HLS.js audio tracks
                if (hls.audioTracks && hls.audioTracks.length > 0) {
                    audioSelect.innerHTML = hls.audioTracks.map((track, i) => {
                        const label = track.name || track.lang || `Audio ${i + 1}`;
                        return `<option value="${i}">${label}</option>`;
                    }).join("");
                    audioSelect.disabled = false;
                    audioSelect.value = hls.audioTrack.toString();
                }

                video.play().catch(() => {});
            });

            hls.on(Hls.Events.FRAG_LOADING, function() {
                if (isLive) {
                    setStatus("", "#ffd43b", true);
                }
            });

            hls.on(Hls.Events.FRAG_LOADED, function() {
                setStatus("", "#51cf66");
            });

            hls.on(Hls.Events.ERROR, function(event, data) {
                if (data.fatal) {
                    setStatus("Error", "#ff6b6b");
                }
            });
        }

        // Download button
        downloadBtn.addEventListener("click", function() {
            if (currentFile) {
                const downloadUrl = "/direct/" + encodeFilePath(currentFile);
                const a = document.createElement("a");
                a.href = downloadUrl;
                a.download = currentFile.split("/").pop();
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }
        });

        // Metrics
        const metricsToggle = document.getElementById("metricsToggle");
        const metricsPanel = document.getElementById("metricsPanel");
        let metricsInterval = null;

        metricsToggle.addEventListener("click", function() {
            this.classList.toggle("active");
            metricsPanel.classList.toggle("active");

            if (metricsPanel.classList.contains("active")) {
                fetchMetrics();
                metricsInterval = setInterval(fetchMetrics, 2000);
            } else {
                if (metricsInterval) {
                    clearInterval(metricsInterval);
                    metricsInterval = null;
                }
            }
        });

        async function fetchMetrics() {
            try {
                const response = await fetch("/transcode/metrics");
                if (!response.ok) return;

                const data = await response.json();

                const formatRatio = (ratio) => ratio ? ratio.toFixed(1) + "%" : "-";
                const getRatioClass = (ratio) => {
                    if (!ratio) return "";
                    if (ratio < 25) return "good";
                    if (ratio < 75) return "warning";
                    return "bad";
                };

                document.getElementById("metricRatioAvg").textContent = formatRatio(data.transcode_ratio_avg);
                document.getElementById("metricRatioAvg").className = "metric-value " + getRatioClass(data.transcode_ratio_avg);

                document.getElementById("metricRatioLast").textContent = formatRatio(data.transcode_ratio_last);
                document.getElementById("metricRatioLast").className = "metric-value " + getRatioClass(data.transcode_ratio_last);

                document.getElementById("metricRatioMin").textContent = formatRatio(data.transcode_ratio_min);
                document.getElementById("metricRatioMin").className = "metric-value good";

                document.getElementById("metricRatioMax").textContent = formatRatio(data.transcode_ratio_max);
                document.getElementById("metricRatioMax").className = "metric-value " + getRatioClass(data.transcode_ratio_max);

                document.getElementById("metricCacheHit").textContent = data.cache_hit_rate ? data.cache_hit_rate.toFixed(1) + "%" : "-";
                document.getElementById("metricCacheHit").className = "metric-value " + (data.cache_hit_rate > 50 ? "good" : "");

                document.getElementById("metricSegments").textContent = data.total_segments || 0;

            } catch (err) {}
        }

        // Handle URL hash routing
        function handleHashRoute() {
            const hash = window.location.hash;
            if (hash.startsWith("#/play/")) {
                const encodedPath = hash.substring(7);
                const filePath = decodeURIComponent(encodedPath);

                if (filePath) {
                    const lastSlash = filePath.lastIndexOf("/");
                    const directory = lastSlash > 0 ? filePath.substring(0, lastSlash) : "";
                    const fileName = lastSlash > 0 ? filePath.substring(lastSlash + 1) : filePath;

                    currentPath = directory;
                    switchToPlayerMode();
                    loadSidebarFiles(directory).then(() => {
                        setTimeout(() => {
                            playFile(filePath, fileName);
                        }, 100);
                    });
                }
            }
        }

        window.addEventListener("hashchange", handleHashRoute);
        window.addEventListener("popstate", () => {
            if (!window.location.hash.startsWith("#/play/") && isPlayerMode) {
                switchToBrowseMode();
            }
        });

        // Initial load
        if (window.location.hash.startsWith("#/play/")) {
            handleHashRoute();
        } else {
            loadBrowseView("");
        }
    </script>
</body>
</html>
