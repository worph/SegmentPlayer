<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SegmentPlayer - Media Browser</title>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem;
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }
        h1 {
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }
        h1:hover {
            opacity: 0.8;
        }
        .badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            background: #4dabf7;
            color: #000;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: bold;
        }
        .header-buttons {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }
        .header-btn {
            background: none;
            border: 1px solid #333;
            color: #888;
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            text-decoration: none;
            transition: all 0.2s;
        }
        .header-btn:hover {
            border-color: #4dabf7;
            color: #4dabf7;
        }

        /* ============ BROWSE MODE ============ */
        .browse-view {
            display: block;
        }
        .browse-view.hidden {
            display: none;
        }
        .browse-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        .browse-breadcrumb {
            font-size: 0.9rem;
            color: #888;
        }
        .browse-breadcrumb span {
            cursor: pointer;
            color: #4dabf7;
        }
        .browse-breadcrumb span:hover {
            text-decoration: underline;
        }
        .browse-stats {
            font-size: 0.85rem;
            color: #666;
        }
        .media-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
        }
        .media-card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        .media-card:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(77, 171, 247, 0.3);
            transform: translateY(-2px);
        }
        .media-card.folder {
            background: rgba(255, 212, 59, 0.05);
        }
        .media-card.folder:hover {
            background: rgba(255, 212, 59, 0.1);
            border-color: rgba(255, 212, 59, 0.3);
        }
        .media-card-icon {
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            background: rgba(0,0,0,0.2);
        }
        .media-card.folder .media-card-icon {
            background: rgba(255, 212, 59, 0.1);
        }
        .media-card-info {
            padding: 1rem;
        }
        .media-card-name {
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            word-break: break-word;
            line-height: 1.3;
        }
        .media-card-meta {
            font-size: 0.8rem;
            color: #888;
            display: flex;
            gap: 1rem;
        }

        /* ============ PLAYER MODE ============ */
        .player-view {
            display: none;
        }
        .player-view.active {
            display: block;
        }
        .layout {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 1.5rem;
        }
        @media (max-width: 900px) {
            .layout {
                grid-template-columns: 1fr;
            }
            /* On mobile: player first, file browser second */
            .player-section {
                order: 1;
            }
            .file-browser {
                order: 2;
            }
        }

        /* File Browser Sidebar */
        .file-browser {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            overflow: hidden;
        }
        .file-browser-header {
            padding: 1rem;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-weight: 600;
        }
        .file-list {
            max-height: 70vh;
            overflow-y: auto;
        }
        @media (max-width: 900px) {
            .file-list {
                max-height: 50vh;
            }
        }
        .file-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            transition: background 0.2s;
        }
        .file-item:hover {
            background: rgba(255,255,255,0.1);
        }
        .file-item.active {
            background: rgba(77, 171, 247, 0.2);
            border-left: 3px solid #4dabf7;
        }
        .file-item.folder {
            color: #ffd43b;
        }
        .file-icon {
            font-size: 1.2rem;
            flex-shrink: 0;
            margin-top: 0.1rem;
        }
        .file-name {
            flex: 1;
            font-size: 0.9rem;
            word-break: break-word;
            line-height: 1.3;
        }
        .file-size {
            color: #888;
            font-size: 0.8rem;
            flex-shrink: 0;
            white-space: nowrap;
        }
        .sidebar-breadcrumb {
            padding: 0.5rem 1rem;
            background: rgba(0,0,0,0.1);
            font-size: 0.85rem;
            color: #888;
        }
        .sidebar-breadcrumb span {
            cursor: pointer;
            color: #4dabf7;
        }
        .sidebar-breadcrumb span:hover {
            text-decoration: underline;
        }

        /* Player Section */
        .player-section {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .video-container {
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }
        video {
            width: 100%;
            display: block;
            max-height: 60vh;
        }
        @media (max-width: 900px) {
            video {
                max-height: 40vh;
            }
        }
        .controls {
            padding: 1rem;
            background: #111;
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            align-items: center;
        }
        @media (max-width: 900px) {
            .controls {
                padding: 0.75rem;
                gap: 0.5rem;
            }
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        @media (max-width: 900px) {
            .control-group {
                gap: 0.3rem;
            }
        }
        .controls label {
            color: #888;
            font-size: 0.85rem;
        }
        @media (max-width: 900px) {
            .controls label {
                font-size: 0.75rem;
            }
        }
        .controls select {
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            border: 1px solid #333;
            background: #222;
            color: #fff;
            font-size: 0.85rem;
            cursor: pointer;
            min-width: 120px;
        }
        @media (max-width: 900px) {
            .controls select {
                padding: 0.3rem 0.5rem;
                font-size: 0.75rem;
                min-width: 90px;
            }
        }
        .controls select:hover {
            border-color: #555;
        }
        .controls input[type="checkbox"] {
            margin-right: 0.4rem;
            cursor: pointer;
        }
        .controls button {
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            border: 1px solid #333;
            background: #222;
            color: #fff;
            font-size: 0.85rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            transition: all 0.2s;
        }
        .controls button:hover {
            border-color: #4dabf7;
            background: rgba(77, 171, 247, 0.1);
        }
        .controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .status {
            margin-left: auto;
            padding: 0.4rem 0.8rem;
            background: #222;
            border-radius: 6px;
            font-size: 0.8rem;
            color: #4dabf7;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            flex-shrink: 0;
        }
        .status-dot.pulse {
            animation: pulse 1s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        /* Subtitle loading indicator (inline) */
        .subtitle-loading {
            display: none;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.75rem;
            color: #ffd43b;
            margin-left: 0.25rem;
        }
        .subtitle-loading.active {
            display: inline-flex;
        }
        .subtitle-loading .mini-spinner {
            width: 12px;
            height: 12px;
            border: 2px solid #333;
            border-top-color: #ffd43b;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        /* Subtitle progress bar (below video) */
        .subtitle-progress {
            display: none;
            background: linear-gradient(135deg, rgba(255, 212, 59, 0.15), rgba(255, 146, 43, 0.15));
            border: 1px solid rgba(255, 212, 59, 0.3);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            margin-top: 0.5rem;
        }
        .subtitle-progress.active {
            display: block;
        }
        .subtitle-progress-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            color: #ffd43b;
            font-size: 0.85rem;
        }
        .subtitle-progress-header .spinner {
            width: 14px;
            height: 14px;
            border: 2px solid #333;
            border-top-color: #ffd43b;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        .subtitle-progress-bar {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        .subtitle-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd43b, #ff922b);
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s ease;
            animation: progress-pulse 1.5s ease-in-out infinite;
        }
        @keyframes progress-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .subtitle-progress-text {
            font-size: 0.75rem;
            color: #888;
            margin-top: 0.4rem;
        }

        /* Now Playing */
        .now-playing {
            padding: 1rem;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }
        .now-playing-title {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 0.25rem;
        }
        .now-playing-name {
            font-size: 1.1rem;
            font-weight: 500;
            word-break: break-word;
        }

        /* Metrics Panel */
        .metrics-panel {
            padding: 1rem;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            font-size: 0.85rem;
            display: none;
        }
        .metrics-panel.active {
            display: block;
        }
        .metrics-section {
            margin-bottom: 1.25rem;
        }
        .metrics-section:last-child {
            margin-bottom: 0;
        }
        .metrics-panel h3 {
            color: #22d3ee;
            margin-bottom: 0.75rem;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 0.5rem;
        }
        .metric-item {
            background: rgba(0,0,0,0.2);
            padding: 0.6rem;
            border-radius: 6px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: #fff;
        }
        .metric-value.good { color: #51cf66; }
        .metric-value.warning { color: #ffd43b; }
        .metric-value.bad { color: #ff6b6b; }
        .metric-label {
            font-size: 0.65rem;
            color: #888;
            margin-top: 0.2rem;
            text-transform: uppercase;
        }

        /* Adaptive Quality Display */
        .adaptive-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }
        .adaptive-item {
            background: rgba(0,0,0,0.25);
            border-radius: 8px;
            padding: 0.75rem;
            text-align: center;
        }
        .adaptive-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 0.3rem;
            letter-spacing: 0.03em;
        }
        .adaptive-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: #fff;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
        }
        .adaptive-bar {
            height: 10px;
            border-radius: 5px;
            position: relative;
            margin-bottom: 0.3rem;
        }
        /* Preset bar: left=fast(orange) ‚Üí right=slow(blue/quality) */
        .adaptive-bar.preset-bar {
            background: linear-gradient(to right, #ff922b, #ffd43b 30%, #51cf66 60%, #4dabf7);
        }
        /* CRF bar: left=0(green/best) ‚Üí right=+7(red/fast) */
        .adaptive-bar.crf-bar {
            background: linear-gradient(to right, #51cf66, #ffd43b 40%, #ff922b 70%, #ff6b6b);
        }
        .adaptive-bar-fill {
            position: absolute;
            top: -2px;
            height: 14px;
            width: 6px;
            background: #fff;
            border-radius: 3px;
            box-shadow: 0 0 6px rgba(0,0,0,0.5), 0 0 3px rgba(255,255,255,0.8);
            transition: left 0.3s ease;
            transform: translateX(-50%);
        }
        .adaptive-range {
            display: flex;
            justify-content: space-between;
            font-size: 0.6rem;
            color: #666;
            margin-top: 0.15rem;
        }
        .adaptive-range .range-good {
            color: #51cf66;
        }
        .adaptive-range .range-fast {
            color: #ff922b;
        }
        .adaptive-stats {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            margin-top: 0.5rem;
        }
        .adaptive-stats span {
            padding: 0.2rem 0.5rem;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        .stat-up { color: #51cf66; }
        .stat-down { color: #ff6b6b; }

        /* Ratio Gauge */
        .ratio-gauge {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 0.75rem;
        }
        .ratio-bar {
            position: relative;
            height: 24px;
            background: linear-gradient(to right,
                #51cf66 0%, #51cf66 50%,
                #ffd43b 50%, #ffd43b 70%,
                #51cf66 70%, #51cf66 80%,
                #ffd43b 80%, #ffd43b 90%,
                #ff6b6b 90%, #ff6b6b 100%
            );
            border-radius: 4px;
            margin-bottom: 0.4rem;
            overflow: visible;
        }
        .ratio-target {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 4px;
            box-sizing: border-box;
        }
        .ratio-needle {
            position: absolute;
            top: -6px;
            width: 4px;
            height: 36px;
            background: #fff;
            border-radius: 2px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            transform: translateX(-50%);
            transition: left 0.3s ease;
            left: 0%;
        }
        .ratio-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            color: #666;
            padding: 0 0.25rem;
        }
        .ratio-labels .target-label {
            color: #51cf66;
            font-weight: 600;
        }
        .ratio-value {
            text-align: center;
            font-size: 1.5rem;
            font-weight: 700;
            margin-top: 0.5rem;
        }
        .ratio-value.good { color: #51cf66; }
        .ratio-value.warning { color: #ffd43b; }
        .ratio-value.bad { color: #ff6b6b; }

        /* Loading & Empty States */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: #888;
        }
        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid #333;
            border-top-color: #4dabf7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 0.75rem;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: #666;
            text-align: center;
        }
        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 id="homeBtn">
                SegmentPlayer <span class="badge">LIVE</span>
            </h1>
            <div class="header-buttons">
                <button class="header-btn" id="metricsToggle">Metrics</button>
            </div>
        </header>

        <!-- Browse Mode: Full-page media grid -->
        <div class="browse-view" id="browseView">
            <div class="browse-header">
                <div class="browse-breadcrumb" id="browseBreadcrumb"></div>
                <div class="browse-stats" id="browseStats"></div>
            </div>
            <div class="media-grid" id="mediaGrid">
                <div class="loading">
                    <div class="spinner"></div>
                    Loading media...
                </div>
            </div>
        </div>

        <!-- Player Mode: Sidebar + Player -->
        <div class="player-view" id="playerView">
            <div class="layout">
                <!-- File Browser Sidebar -->
                <div class="file-browser">
                    <div class="file-browser-header">Media Files</div>
                    <div class="sidebar-breadcrumb" id="sidebarBreadcrumb"></div>
                    <div class="file-list" id="fileList"></div>
                </div>

                <!-- Player Section -->
                <div class="player-section">
                    <div class="video-container">
                        <video id="video" controls crossorigin="anonymous" autoplay></video>
                        <div class="controls">
                            <div class="control-group">
                                <label>Quality:</label>
                                <select id="resolutionSelect" disabled>
                                    <option value="auto">Auto</option>
                                    <option value="original">Original</option>
                                    <option value="1080p">1080p</option>
                                    <option value="720p">720p</option>
                                    <option value="480p">480p</option>
                                    <option value="360p">360p</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label>Audio:</label>
                                <select id="audioSelect" disabled>
                                    <option value="">Default</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label>Subtitles:</label>
                                <select id="subtitleSelect" disabled>
                                    <option value="">Off</option>
                                </select>
                                <span class="subtitle-loading" id="subtitleLoading">
                                    <span class="mini-spinner"></span>
                                    <span>Generating...</span>
                                </span>
                            </div>
                            <button id="downloadBtn" disabled title="Download original file">
                                <span>Download</span>
                            </button>
                            <span class="status" id="status"><span class="status-dot" id="statusDot"></span><span id="statusText">Select a file</span></span>
                        </div>
                    </div>

                    <div class="subtitle-progress" id="subtitleProgress">
                        <div class="subtitle-progress-header">
                            <span class="spinner"></span>
                            <span>Generating subtitles...</span>
                        </div>
                        <div class="subtitle-progress-bar">
                            <div class="subtitle-progress-fill" id="subtitleProgressFill"></div>
                        </div>
                        <div class="subtitle-progress-text" id="subtitleProgressText">Extracting subtitle track from video...</div>
                    </div>

                    <div class="now-playing" id="nowPlaying" style="display: none;">
                        <div class="now-playing-title">Now Playing</div>
                        <div class="now-playing-name" id="nowPlayingName"></div>
                    </div>

                    <div class="metrics-panel" id="metricsPanel">
                        <div class="metrics-section">
                            <h3>Player Mode</h3>
                            <div class="metrics-grid" style="grid-template-columns: 1fr 1fr 1fr 1fr;">
                                <div class="metric-item">
                                    <div class="metric-value" id="metricMode">-</div>
                                    <div class="metric-label">Mode</div>
                                </div>
                                <div class="metric-item">
                                    <div class="metric-value" id="metricVideoCodec">-</div>
                                    <div class="metric-label">Video</div>
                                </div>
                                <div class="metric-item">
                                    <div class="metric-value" id="metricAudioCodec">-</div>
                                    <div class="metric-label">Audio</div>
                                </div>
                                <div class="metric-item" style="display: flex; align-items: center; justify-content: center;">
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.85rem; color: #888;">
                                        <input type="checkbox" id="forceTranscode" style="cursor: pointer;"> Force Transcode
                                    </label>
                                </div>
                            </div>
                            <div style="font-size: 0.75rem; color: #666; margin-top: 0.5rem; line-height: 1.4;">
                                <b>Repack</b>: H.264 + AAC only (fast, no CPU). <b>Transcode</b>: HEVC, AV1, VP9, AC3, DTS, 10-bit (re-encodes to H.264+AAC).
                            </div>
                        </div>
                        <div class="metrics-section">
                            <h3>Adaptive Quality <span id="adaptiveQualityRes" style="font-weight: normal; color: #888;"></span></h3>
                            <div class="adaptive-grid">
                                <div class="adaptive-item">
                                    <div class="adaptive-label">Encoder Preset</div>
                                    <div class="adaptive-value" id="metricPreset">fast</div>
                                    <div class="adaptive-bar preset-bar">
                                        <div class="adaptive-bar-fill" id="presetBar"></div>
                                    </div>
                                    <div class="adaptive-range">
                                        <span class="range-fast">ultrafast</span>
                                        <span class="range-good">veryslow</span>
                                    </div>
                                    <div class="adaptive-stats">
                                        <span class="stat-up" id="presetAdjustUp" title="Quality increases">&#9650; 0</span>
                                        <span class="stat-down" id="presetAdjustDown" title="Quality decreases">&#9660; 0</span>
                                    </div>
                                </div>
                                <div class="adaptive-item">
                                    <div class="adaptive-label">CRF Offset</div>
                                    <div class="adaptive-value" id="metricCRF">+0</div>
                                    <div class="adaptive-bar crf-bar">
                                        <div class="adaptive-bar-fill" id="crfBar"></div>
                                    </div>
                                    <div class="adaptive-range">
                                        <span class="range-good">+0 best</span>
                                        <span class="range-fast">+7 fast</span>
                                    </div>
                                    <div class="adaptive-stats">
                                        <span class="stat-up" id="crfAdjustDown" title="Quality increases">&#9650; 0</span>
                                        <span class="stat-down" id="crfAdjustUp" title="Quality decreases">&#9660; 0</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="metrics-section">
                            <h3>Transcode Ratio</h3>
                            <div class="ratio-gauge">
                                <div class="ratio-bar">
                                    <div class="ratio-target" style="left: 70%; width: 10%;"></div>
                                    <div class="ratio-needle" id="ratioNeedle"></div>
                                </div>
                                <div class="ratio-labels">
                                    <span>0%</span>
                                    <span>50%</span>
                                    <span class="target-label">70-80%</span>
                                    <span>100%</span>
                                </div>
                                <div class="ratio-value" id="ratioValue">-</div>
                            </div>
                        </div>
                        <div class="metrics-section">
                            <h3>Performance</h3>
                            <div class="metrics-grid">
                                <div class="metric-item">
                                    <div class="metric-value" id="metricRatioAvg">-</div>
                                    <div class="metric-label">Avg Ratio</div>
                                </div>
                                <div class="metric-item">
                                    <div class="metric-value" id="metricRatioLast">-</div>
                                    <div class="metric-label">Last Ratio</div>
                                </div>
                                <div class="metric-item">
                                    <div class="metric-value" id="metricRatioMin">-</div>
                                    <div class="metric-label">Best</div>
                                </div>
                                <div class="metric-item">
                                    <div class="metric-value" id="metricRatioMax">-</div>
                                    <div class="metric-label">Worst</div>
                                </div>
                                <div class="metric-item">
                                    <div class="metric-value" id="metricCacheHit">-</div>
                                    <div class="metric-label">Cache Hit</div>
                                </div>
                                <div class="metric-item">
                                    <div class="metric-value" id="metricSegments">-</div>
                                    <div class="metric-label">Segments</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const video = document.getElementById("video");
        const audioSelect = document.getElementById("audioSelect");
        const subtitleSelect = document.getElementById("subtitleSelect");
        const resolutionSelect = document.getElementById("resolutionSelect");
        const statusEl = document.getElementById("status");
        const statusDot = document.getElementById("statusDot");
        const statusText = document.getElementById("statusText");
        const fileList = document.getElementById("fileList");
        const mediaGrid = document.getElementById("mediaGrid");
        const browseView = document.getElementById("browseView");
        const playerView = document.getElementById("playerView");
        const browseBreadcrumb = document.getElementById("browseBreadcrumb");
        const sidebarBreadcrumb = document.getElementById("sidebarBreadcrumb");
        const browseStats = document.getElementById("browseStats");
        const nowPlaying = document.getElementById("nowPlaying");
        const nowPlayingName = document.getElementById("nowPlayingName");
        const downloadBtn = document.getElementById("downloadBtn");
        const homeBtn = document.getElementById("homeBtn");
        const subtitleLoading = document.getElementById("subtitleLoading");
        const subtitleProgress = document.getElementById("subtitleProgress");
        const subtitleProgressFill = document.getElementById("subtitleProgressFill");
        const subtitleProgressText = document.getElementById("subtitleProgressText");

        let hls = null;
        let currentPath = "";
        let currentFile = null;
        let currentResolution = "auto";
        let actualResolution = null; // Actual resolution being played (for auto mode)
        let subtitleProgressInterval = null;
        let isPlayerMode = false;
        let isTranscoding = false; // true = transcode, false = repack/direct

        // Configuration
        const urlParams = new URLSearchParams(window.location.search);
        const MAX_BUFFER_LENGTH = parseInt(urlParams.get('buffer') || '300');

        // Video/subtitle extensions
        const videoExtensions = [".mp4", ".mkv", ".mov", ".avi", ".webm", ".m4v", ".ts", ".m2ts"];
        const subtitleExtensions = [".vtt", ".srt", ".ass", ".ssa"];

        // Status helper
        function setStatus(text, color, pulsing = false) {
            statusText.textContent = text;
            statusEl.style.color = color;
            statusDot.classList.toggle("pulse", pulsing);
        }

        // Update player mode display
        function updateModeDisplay() {
            const modeEl = document.getElementById("metricMode");
            const resEl = document.getElementById("adaptiveQualityRes");
            if (modeEl) {
                if (isTranscoding) {
                    modeEl.textContent = "Transcode";
                    modeEl.className = "metric-value warning";
                } else {
                    modeEl.textContent = "Repack";
                    modeEl.className = "metric-value good";
                }
            }
            // Update current quality display
            if (resEl) {
                let qualityText;
                if (currentResolution === "auto") {
                    qualityText = actualResolution ? `Auto (${actualResolution}p)` : "Auto";
                } else if (currentResolution === "original") {
                    qualityText = "Original";
                } else {
                    qualityText = currentResolution + "p";
                }
                resEl.textContent = qualityText;
            }
        }

        // Subtitle progress helpers
        function showSubtitleProgress(trackName) {
            subtitleProgress.classList.add("active");
            subtitleProgressFill.style.width = "0%";
            subtitleProgressText.textContent = `Extracting "${trackName}" from video...`;

            // Animate progress bar (simulated since we don't have real progress)
            let progress = 0;
            if (subtitleProgressInterval) clearInterval(subtitleProgressInterval);
            subtitleProgressInterval = setInterval(() => {
                // Slow down as we approach 90% (never reach 100% until actually done)
                const remaining = 90 - progress;
                const increment = Math.max(0.5, remaining * 0.1);
                progress = Math.min(90, progress + increment);
                subtitleProgressFill.style.width = progress + "%";

                // Update text based on progress
                if (progress < 30) {
                    subtitleProgressText.textContent = `Extracting "${trackName}" from video...`;
                } else if (progress < 60) {
                    subtitleProgressText.textContent = `Converting subtitle format...`;
                } else {
                    subtitleProgressText.textContent = `Finalizing subtitles...`;
                }
            }, 200);
        }

        function hideSubtitleProgress(success = true) {
            if (subtitleProgressInterval) {
                clearInterval(subtitleProgressInterval);
                subtitleProgressInterval = null;
            }

            if (success) {
                subtitleProgressFill.style.width = "100%";
                subtitleProgressText.textContent = "Subtitles loaded!";
                setTimeout(() => {
                    subtitleProgress.classList.remove("active");
                }, 500);
            } else {
                subtitleProgress.classList.remove("active");
            }
        }

        // Format file size
        function formatSize(bytes) {
            if (bytes === 0) return "0 B";
            const k = 1024;
            const sizes = ["B", "KB", "MB", "GB"];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + " " + sizes[i];
        }

        function isVideo(name) {
            const lower = name.toLowerCase();
            return videoExtensions.some(ext => lower.endsWith(ext));
        }

        function isSubtitle(name) {
            const lower = name.toLowerCase();
            return subtitleExtensions.some(ext => lower.endsWith(ext));
        }

        function getIcon(item) {
            if (item.type === "directory") return "üìÅ";
            if (isVideo(item.name)) return "üé¨";
            if (isSubtitle(item.name)) return "üìù";
            return "üìÑ";
        }

        function encodeFilePath(path) {
            return path.split('/').map(part => encodeURIComponent(part)).join('/');
        }

        // Switch between browse and player modes
        function switchToPlayerMode() {
            if (isPlayerMode) return;
            isPlayerMode = true;
            browseView.classList.add("hidden");
            playerView.classList.add("active");
        }

        function switchToBrowseMode() {
            if (!isPlayerMode) return;
            isPlayerMode = false;
            playerView.classList.remove("active");
            browseView.classList.remove("hidden");

            // Stop video and clear
            if (hls) {
                hls.destroy();
                hls = null;
            }
            video.src = "";
            currentFile = null;

            // Clear URL hash
            history.pushState(null, "", window.location.pathname);

            // Reload browse view with current path
            loadBrowseView(currentPath);
        }

        // Home button
        homeBtn.addEventListener("click", () => {
            if (isPlayerMode) {
                switchToBrowseMode();
            } else {
                currentPath = "";
                loadBrowseView("");
            }
        });

        // Update URL hash when playing
        function updateUrlHash(filePath) {
            const encodedPath = encodeFilePath(filePath);
            history.pushState(null, "", `#/play/${encodedPath}`);
        }

        // Build breadcrumb HTML
        function buildBreadcrumb(path, targetId) {
            const parts = path ? path.split("/") : [];
            let html = '<span data-path="">Home</span>';
            let accumulated = "";

            parts.forEach((part) => {
                accumulated += (accumulated ? "/" : "") + part;
                html += ` / <span data-path="${accumulated}">${part}</span>`;
            });

            const container = document.getElementById(targetId);
            container.innerHTML = html;

            container.querySelectorAll("span").forEach(span => {
                span.addEventListener("click", () => {
                    currentPath = span.dataset.path;
                    if (isPlayerMode) {
                        loadSidebarFiles(currentPath);
                    } else {
                        loadBrowseView(currentPath);
                    }
                });
            });
        }

        // Load browse view (full-page grid)
        async function loadBrowseView(path = "") {
            mediaGrid.innerHTML = '<div class="loading"><div class="spinner"></div>Loading media...</div>';
            buildBreadcrumb(path, "browseBreadcrumb");

            try {
                const response = await fetch("/api/files/" + (path ? path + "/" : ""));
                if (!response.ok) throw new Error("Failed to load files");

                const files = await response.json();

                // Sort: folders first, then by name
                files.sort((a, b) => {
                    if (a.type === "directory" && b.type !== "directory") return -1;
                    if (a.type !== "directory" && b.type === "directory") return 1;
                    return a.name.localeCompare(b.name);
                });

                // Filter to show only videos and folders
                const filtered = files.filter(f => f.type === "directory" || isVideo(f.name));

                // Stats
                const folderCount = filtered.filter(f => f.type === "directory").length;
                const videoCount = filtered.filter(f => f.type !== "directory").length;
                browseStats.textContent = `${folderCount} folders, ${videoCount} videos`;

                if (filtered.length === 0) {
                    mediaGrid.innerHTML = `
                        <div class="empty-state" style="grid-column: 1 / -1;">
                            <div class="empty-state-icon">üìÇ</div>
                            <div>No media files found</div>
                            <div style="font-size: 0.85rem; margin-top: 0.5rem; color: #888;">
                                Add video files to your media folder
                            </div>
                        </div>
                    `;
                    return;
                }

                mediaGrid.innerHTML = filtered.map(file => {
                    const fullPath = path ? path + "/" + file.name : file.name;
                    const isFolder = file.type === "directory";

                    return `
                        <div class="media-card ${isFolder ? 'folder' : ''}"
                             data-path="${fullPath}"
                             data-type="${file.type}"
                             data-name="${file.name}">
                            <div class="media-card-icon">${getIcon(file)}</div>
                            <div class="media-card-info">
                                <div class="media-card-name" title="${file.name}">${file.name}</div>
                                <div class="media-card-meta">
                                    ${isFolder ? '<span>Folder</span>' : `<span>${formatSize(file.size || 0)}</span>`}
                                </div>
                            </div>
                        </div>
                    `;
                }).join("");

                // Add click handlers
                mediaGrid.querySelectorAll(".media-card").forEach(card => {
                    card.addEventListener("click", () => {
                        const cardPath = card.dataset.path;
                        const cardType = card.dataset.type;
                        const cardName = card.dataset.name;

                        if (cardType === "directory") {
                            currentPath = cardPath;
                            loadBrowseView(cardPath);
                        } else if (isVideo(cardName)) {
                            // Switch to player mode and play
                            switchToPlayerMode();
                            loadSidebarFiles(currentPath).then(() => {
                                playFile(cardPath, cardName);
                            });
                        }
                    });
                });

            } catch (err) {
                console.error("Error loading files:", err);
                mediaGrid.innerHTML = `
                    <div class="empty-state" style="grid-column: 1 / -1;">
                        <div class="empty-state-icon">‚ö†Ô∏è</div>
                        <div>Error loading files</div>
                        <div style="font-size: 0.85rem; margin-top: 0.5rem;">${err.message}</div>
                    </div>
                `;
            }
        }

        // Load sidebar files (player mode)
        async function loadSidebarFiles(path = "") {
            fileList.innerHTML = '<div class="loading"><div class="spinner"></div>Loading...</div>';
            buildBreadcrumb(path, "sidebarBreadcrumb");

            try {
                const response = await fetch("/api/files/" + (path ? path + "/" : ""));
                if (!response.ok) throw new Error("Failed to load files");

                const files = await response.json();

                files.sort((a, b) => {
                    if (a.type === "directory" && b.type !== "directory") return -1;
                    if (a.type !== "directory" && b.type === "directory") return 1;
                    return a.name.localeCompare(b.name);
                });

                const filtered = files.filter(f => f.type === "directory" || isVideo(f.name) || isSubtitle(f.name));

                if (filtered.length === 0) {
                    fileList.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üìÇ</div>
                            <div>No media files</div>
                        </div>
                    `;
                    return;
                }

                fileList.innerHTML = filtered.map(file => {
                    const fullPath = path ? path + "/" + file.name : file.name;
                    const isActive = currentFile === fullPath;
                    const isFolder = file.type === "directory";

                    return `
                        <div class="file-item ${isFolder ? 'folder' : ''} ${isActive ? 'active' : ''}"
                             data-path="${fullPath}"
                             data-type="${file.type}"
                             data-name="${file.name}">
                            <span class="file-icon">${getIcon(file)}</span>
                            <span class="file-name">${file.name}</span>
                            ${file.size ? `<span class="file-size">${formatSize(file.size)}</span>` : ''}
                        </div>
                    `;
                }).join("");

                fileList.querySelectorAll(".file-item").forEach(item => {
                    item.addEventListener("click", () => {
                        const itemPath = item.dataset.path;
                        const itemType = item.dataset.type;
                        const itemName = item.dataset.name;

                        if (itemType === "directory") {
                            currentPath = itemPath;
                            loadSidebarFiles(itemPath);
                        } else if (isVideo(itemName)) {
                            playFile(itemPath, itemName);
                        }
                    });
                });

            } catch (err) {
                console.error("Error loading files:", err);
                fileList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ö†Ô∏è</div>
                        <div>Error</div>
                    </div>
                `;
            }
        }

        // Find subtitles for video
        async function findSubtitles(videoPath) {
            const dir = videoPath.substring(0, videoPath.lastIndexOf("/")) || "";
            const videoName = videoPath.substring(videoPath.lastIndexOf("/") + 1);
            const baseName = videoName.substring(0, videoName.lastIndexOf("."));

            try {
                const response = await fetch("/api/files/" + (dir ? dir + "/" : ""));
                if (!response.ok) return [];

                const files = await response.json();
                return files
                    .filter(f => isSubtitle(f.name) && f.name.startsWith(baseName))
                    .map(f => ({
                        name: f.name,
                        path: dir ? dir + "/" + f.name : f.name,
                        lang: extractLang(f.name, baseName)
                    }));
            } catch {
                return [];
            }
        }

        function extractLang(subName, baseName) {
            const withoutBase = subName.substring(baseName.length);
            const match = withoutBase.match(/[._]([a-z]{2,3})/i);
            return match ? match[1].toUpperCase() : "Unknown";
        }

        // Reset metrics
        async function resetMetrics() {
            try {
                await fetch("/transcode/reset-metrics");
            } catch (e) {}
        }

        // Play video file
        async function playFile(filePath, fileName) {
            currentFile = filePath;
            const forceTranscode = document.getElementById("forceTranscode").checked;

            // Update URL hash
            updateUrlHash(filePath);

            resetMetrics();

            // Update sidebar active state
            document.querySelectorAll(".file-item").forEach(item => {
                item.classList.toggle("active", item.dataset.path === filePath);
            });

            nowPlaying.style.display = "block";
            nowPlayingName.textContent = fileName;
            setStatus("Loading...", "#4dabf7", true);

            downloadBtn.disabled = false;
            downloadBtn.title = "Download: " + fileName;

            if (hls) {
                hls.destroy();
                hls = null;
            }

            audioSelect.innerHTML = '<option value="">Loading...</option>';
            audioSelect.disabled = true;
            subtitleSelect.innerHTML = '<option value="">Off</option>';
            subtitleSelect.disabled = true;
            currentAudioIdx = 0;

            video.querySelectorAll("track").forEach(t => t.remove());

            if (forceTranscode) {
                tryTranscodedFallback(filePath, fileName);
                return;
            }

            // Direct HLS = repack mode
            isTranscoding = false;
            updateModeDisplay();

            const videoSrc = "/hls/" + encodeURIComponent(filePath) + "/master.m3u8";

            if (Hls.isSupported()) {
                hls = new Hls({
                    debug: false,
                    enableWorker: true,
                    lowLatencyMode: false,
                    maxBufferLength: 30,
                    maxMaxBufferLength: 60
                });

                hls.loadSource(videoSrc);
                hls.attachMedia(video);

                hls.on(Hls.Events.MANIFEST_PARSED, async function(event, data) {
                    setStatus("Ready", "#51cf66");

                    if (hls.audioTracks && hls.audioTracks.length > 0) {
                        audioSelect.innerHTML = hls.audioTracks.map((track, i) => {
                            const label = track.name || track.lang || `Track ${i + 1}`;
                            return `<option value="${i}">${label}</option>`;
                        }).join("");
                        audioSelect.disabled = false;
                        audioSelect.value = hls.audioTrack;
                        currentAudioIdx = hls.audioTrack;
                    } else {
                        audioSelect.innerHTML = '<option value="">Default</option>';
                        audioSelect.disabled = true;
                        currentAudioIdx = 0;
                    }

                    const subs = await findSubtitles(filePath);
                    if (subs.length > 0) {
                        subtitleSelect.innerHTML = '<option value="">Off</option>' +
                            subs.map(sub => `<option value="${sub.path}">${sub.lang}</option>`).join("");
                        subtitleSelect.disabled = false;
                    }

                    video.play().catch(() => {});
                });

                hls.on(Hls.Events.ERROR, function(event, data) {
                    if (data.fatal) {
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                tryTranscodedFallback(filePath, fileName);
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                hls.recoverMediaError();
                                break;
                            default:
                                setStatus("Error", "#ff6b6b");
                        }
                    }
                });

                hls.on(Hls.Events.FRAG_LOADED, function() {
                    setStatus("", "#51cf66");
                });

                // Track actual resolution when level changes (for auto mode display)
                hls.on(Hls.Events.LEVEL_SWITCHED, function(event, data) {
                    if (hls.levels && hls.levels[data.level]) {
                        actualResolution = hls.levels[data.level].height;
                        updateModeDisplay();
                        // Update Auto option in dropdown
                        const autoOption = resolutionSelect.querySelector('option[value="auto"]');
                        if (autoOption) {
                            autoOption.textContent = `Auto (${actualResolution}p)`;
                        }
                    }
                });

            } else if (video.canPlayType("application/vnd.apple.mpegurl")) {
                video.src = videoSrc;
                video.addEventListener("loadedmetadata", function() {
                    setStatus("Ready", "#51cf66");
                    video.play().catch(() => {});
                });
            } else {
                setStatus("HLS not supported", "#ff6b6b");
            }
        }

        // Audio track change - for transcoded mode, audio is muxed into variants
        // so we need to switch to a different variant (stream_aN_*.m3u8)
        let currentAudioIdx = 0;

        // Helper: get audio index from level URL
        function getAudioIdxFromLevel(level) {
            const urlMatch = level.url?.[0]?.match(/stream_a(\d+)_/);
            return urlMatch ? parseInt(urlMatch[1]) : 0;
        }

        // Helper: find levels that use a specific audio track
        function getLevelsForAudioTrack(audioIdx) {
            if (!hls || !hls.levels) return [];
            return hls.levels
                .map((level, idx) => ({ level, idx }))
                .filter(({ level }) => getAudioIdxFromLevel(level) === audioIdx);
        }

        audioSelect.addEventListener("change", function() {
            if (!hls || this.value === "") return;

            const newAudioIdx = parseInt(this.value);
            if (newAudioIdx === currentAudioIdx) return;

            const currentTime = video.currentTime;
            const wasPlaying = !video.paused;

            // For transcoded mode with muxed audio, we need to find the level
            // with the matching audio index and switch to it
            if (isTranscoding && hls.levels && hls.levels.length > 0) {
                const levelsForTrack = getLevelsForAudioTrack(newAudioIdx);

                if (levelsForTrack.length > 0) {
                    // Find current resolution to preserve quality
                    const currentLevelIdx = hls.currentLevel >= 0 ? hls.currentLevel : hls.loadLevel;
                    const currentLevel = hls.levels[currentLevelIdx];
                    const targetHeight = currentLevel ? currentLevel.height : null;

                    // Find best matching level: same resolution, or highest quality
                    let targetLevelIdx = levelsForTrack[0].idx;
                    if (targetHeight) {
                        const exactMatch = levelsForTrack.find(({ level }) => level.height === targetHeight);
                        if (exactMatch) {
                            targetLevelIdx = exactMatch.idx;
                        }
                    }

                    currentAudioIdx = newAudioIdx;

                    // Lock to this level (disable ABR to prevent switching back to old audio)
                    hls.currentLevel = targetLevelIdx;

                    // Update resolution dropdown to match
                    const targetLevel = hls.levels[targetLevelIdx];
                    if (targetLevel) {
                        resolutionSelect.value = targetLevel.height.toString();
                        currentResolution = targetLevel.height.toString();
                        actualResolution = targetLevel.height;
                        updateModeDisplay();
                    }

                    // Force buffer flush and seek to apply change immediately
                    setTimeout(() => {
                        video.currentTime = currentTime + 0.1;
                        setTimeout(() => {
                            video.currentTime = currentTime;
                            if (wasPlaying) video.play();
                        }, 50);
                    }, 100);
                    return;
                }
            }

            // Fallback: try HLS.js native audio track switching (for non-muxed audio)
            if (hls.audioTracks && hls.audioTracks.length > newAudioIdx) {
                hls.audioTrack = newAudioIdx;
                currentAudioIdx = newAudioIdx;
            }
        });

        // Subtitle change
        subtitleSelect.addEventListener("change", function() {
            const val = parseInt(this.value);
            video.querySelectorAll("track").forEach(t => t.remove());
            for (let i = 0; i < video.textTracks.length; i++) {
                video.textTracks[i].mode = "hidden";
            }
            subtitleLoading.classList.remove("active");
            hideSubtitleProgress(false);

            if (val === -1 || this.value === "" || this.value === "-1") return;

            if (hls && hls.subtitleTracks && hls.subtitleTracks.length > 0) {
                hls.subtitleTrack = val;
                return;
            }

            // Show loading indicators for VTT that needs extraction
            subtitleLoading.classList.add("active");

            if (currentTranscodeBase && transcodedSubtitleTracks[val]) {
                const trackName = transcodedSubtitleTracks[val].name || `Track ${val + 1}`;
                showSubtitleProgress(trackName);

                const vttUrl = currentTranscodeBase + "/subs_" + val + ".vtt";
                const track = document.createElement("track");
                track.kind = "subtitles";
                track.src = vttUrl;
                track.default = true;
                track.label = trackName;
                video.appendChild(track);
                track.addEventListener("load", function() {
                    subtitleLoading.classList.remove("active");
                    hideSubtitleProgress(true);
                    if (video.textTracks.length > 0) {
                        video.textTracks[0].mode = "showing";
                    }
                });
                track.addEventListener("error", function() {
                    subtitleLoading.classList.remove("active");
                    hideSubtitleProgress(false);
                });
                return;
            }

            if (this.value) {
                const trackName = this.options[this.selectedIndex].text || "Subtitle";
                showSubtitleProgress(trackName);

                const track = document.createElement("track");
                track.kind = "subtitles";
                track.src = "/subs/" + this.value;
                track.default = true;
                video.appendChild(track);
                track.addEventListener("load", function() {
                    subtitleLoading.classList.remove("active");
                    hideSubtitleProgress(true);
                    if (video.textTracks.length > 0) {
                        video.textTracks[0].mode = "showing";
                    }
                });
                track.addEventListener("error", function() {
                    subtitleLoading.classList.remove("active");
                    hideSubtitleProgress(false);
                });
            }
        });

        // Transcoded fallback
        async function tryTranscodedFallback(filePath, fileName) {
            setStatus("Transcoding...", "#ffd43b", true);

            // Mark as transcode mode
            isTranscoding = true;
            updateModeDisplay();

            const transcodedSrc = "/transcode/" + encodeFilePath(filePath) + "/master.m3u8";

            try {
                const response = await fetch(transcodedSrc);
                if (response.ok) {
                    playTranscoded(transcodedSrc, fileName, true);
                } else {
                    setStatus("Error", "#ff6b6b");
                }
            } catch (err) {
                setStatus("Error", "#ff6b6b");
            }
        }

        let currentTranscodeBase = "";
        let transcodedAudioTracks = [];
        let transcodedSubtitleTracks = [];

        function parseAndPopulateTracks(manifest) {
            transcodedAudioTracks = [];
            transcodedSubtitleTracks = [];

            const lines = manifest.split('\n');
            for (const line of lines) {
                // Parse audio tracks from EXT-X-MEDIA declarations
                if (line.startsWith('#EXT-X-MEDIA:TYPE=AUDIO')) {
                    const name = line.match(/NAME="([^"]+)"/)?.[1] || 'Audio';
                    const uri = line.match(/URI="([^"]+)"/)?.[1] || '';
                    transcodedAudioTracks.push({ name, uri });
                }
                // Parse subtitles from EXT-X-MEDIA declarations
                else if (line.startsWith('#EXT-X-MEDIA:TYPE=SUBTITLES')) {
                    const name = line.match(/NAME="([^"]+)"/)?.[1] || 'Subtitle';
                    const uri = line.match(/URI="([^"]+)"/)?.[1] || '';
                    transcodedSubtitleTracks.push({ name, uri });
                }
            }

            if (transcodedAudioTracks.length > 0) {
                audioSelect.innerHTML = transcodedAudioTracks.map((track, i) =>
                    `<option value="${i}">${track.name}</option>`
                ).join("");
                audioSelect.disabled = false;
                audioSelect.value = "0";
                currentAudioIdx = 0;
            }

            if (transcodedSubtitleTracks.length > 0) {
                subtitleSelect.innerHTML = '<option value="-1">Off</option>' +
                    transcodedSubtitleTracks.map((track, i) =>
                        `<option value="${i}">${track.name}</option>`
                    ).join("");
                subtitleSelect.disabled = false;
            }
        }

        let availableResolutions = [];

        function parseAndPopulateResolutions(manifest) {
            availableResolutions = [];
            const lines = manifest.split('\n');

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.startsWith('#EXT-X-STREAM-INF')) {
                    const resMatch = line.match(/RESOLUTION=(\d+)x(\d+)/);
                    const nextLine = lines[i + 1];
                    if (resMatch && nextLine) {
                        const width = parseInt(resMatch[1]);
                        const height = parseInt(resMatch[2]);
                        const uriMatch = nextLine.match(/stream_a\d+_(\w+)\.m3u8/);
                        if (uriMatch) {
                            const resName = uriMatch[1];
                            availableResolutions.push({
                                name: resName === 'original' ? `Original (${width}x${height})` : `${height}p`,
                                value: resName
                            });
                        }
                    }
                }
            }

            if (availableResolutions.length > 0) {
                resolutionSelect.innerHTML = availableResolutions.map(res =>
                    `<option value="${res.value}">${res.name}</option>`
                ).join("");
                resolutionSelect.value = currentResolution;
            }
        }

        resolutionSelect.addEventListener("change", function() {
            if (!hls || !hls.levels || hls.levels.length === 0) return;

            const newResolution = this.value;
            if (newResolution === currentResolution) return;

            resetMetrics();
            currentResolution = newResolution;
            // Reset actual resolution - will be updated by LEVEL_SWITCHED event
            actualResolution = null;
            updateModeDisplay();

            // For transcoded mode, filter levels by current audio track
            const candidateLevels = isTranscoding
                ? getLevelsForAudioTrack(currentAudioIdx)
                : hls.levels.map((level, idx) => ({ level, idx }));

            // Find the level index matching the selected resolution
            // -1 means auto (ABR) - but for transcoded with multiple audio tracks,
            // we can't use auto because it would switch between audio tracks
            if (newResolution === 'auto') {
                // Only allow auto if there's a single audio track
                const hasMultipleAudioTracks = isTranscoding &&
                    new Set(hls.levels.map(getAudioIdxFromLevel)).size > 1;

                if (hasMultipleAudioTracks) {
                    // Pick highest quality level for current audio track instead
                    const sorted = [...candidateLevels].sort((a, b) => b.level.height - a.level.height);
                    if (sorted.length > 0) {
                        hls.currentLevel = sorted[0].idx;
                    }
                } else {
                    hls.currentLevel = -1;
                }
            } else {
                const targetHeight = parseInt(newResolution) || 0;
                let levelIdx = -1;

                for (const { level, idx } of candidateLevels) {
                    if (newResolution === 'original' || newResolution === 'source') {
                        // Pick highest quality for "original"
                        if (levelIdx === -1 || level.height > hls.levels[levelIdx].height) {
                            levelIdx = idx;
                        }
                    } else if (level.height === targetHeight) {
                        levelIdx = idx;
                        break;
                    }
                }

                if (levelIdx >= 0) {
                    hls.currentLevel = levelIdx;
                }
            }
        });

        async function playTranscoded(url, fileName, isLive = false) {
            if (hls) {
                hls.destroy();
            }

            setStatus(isLive ? "Transcoding..." : "Transcoded", "#ffd43b", isLive);

            currentTranscodeBase = url.replace("/master.m3u8", "");

            try {
                const response = await fetch(url);
                const manifest = await response.text();
                parseAndPopulateTracks(manifest);
                parseAndPopulateResolutions(manifest);
            } catch (e) {}

            resolutionSelect.disabled = false;

            hls = new Hls({
                debug: false,
                enableWorker: true,
                maxBufferLength: MAX_BUFFER_LENGTH,
                maxMaxBufferLength: MAX_BUFFER_LENGTH * 2
            });

            // Load the master playlist - HLS.js will handle audio track switching
            hls.loadSource(url);
            hls.attachMedia(video);

            hls.on(Hls.Events.MANIFEST_PARSED, function(event, data) {
                setStatus("", "#51cf66");

                // Populate resolution dropdown from HLS.js levels
                if (hls.levels && hls.levels.length > 0) {
                    const levels = hls.levels.map((level, i) => ({
                        index: i,
                        height: level.height,
                        width: level.width,
                        bitrate: level.bitrate
                    }));

                    // Sort by height descending
                    levels.sort((a, b) => b.height - a.height);

                    // First option is "Original" (highest quality)
                    const originalHeight = levels[0].height;
                    resolutionSelect.innerHTML =
                        '<option value="auto">Auto</option>' +
                        `<option value="${originalHeight}">Original (${originalHeight}p)</option>` +
                        levels.slice(1).map(l => `<option value="${l.height}">${l.height}p</option>`).join("");
                    resolutionSelect.disabled = false;
                    resolutionSelect.value = "auto";
                    currentResolution = "auto";
                    actualResolution = null;
                    updateModeDisplay();

                    // Set HLS.js to auto (ABR)
                    hls.currentLevel = -1;
                }

                // Populate audio dropdown from HLS.js audio tracks
                if (hls.audioTracks && hls.audioTracks.length > 0) {
                    audioSelect.innerHTML = hls.audioTracks.map((track, i) => {
                        const label = track.name || track.lang || `Audio ${i + 1}`;
                        return `<option value="${i}">${label}</option>`;
                    }).join("");
                    audioSelect.disabled = false;
                    audioSelect.value = hls.audioTrack.toString();
                    currentAudioIdx = hls.audioTrack;
                }

                video.play().catch(() => {});
            });

            hls.on(Hls.Events.FRAG_LOADING, function() {
                if (isLive) {
                    setStatus("", "#ffd43b", true);
                }
            });

            hls.on(Hls.Events.FRAG_LOADED, function() {
                setStatus("", "#51cf66");
            });

            hls.on(Hls.Events.ERROR, function(event, data) {
                if (data.fatal) {
                    setStatus("Error", "#ff6b6b");
                }
            });

            // Track actual resolution when level changes (for auto mode display)
            hls.on(Hls.Events.LEVEL_SWITCHED, function(event, data) {
                if (hls.levels && hls.levels[data.level]) {
                    actualResolution = hls.levels[data.level].height;
                    updateModeDisplay();
                    // Update Auto option in dropdown
                    const autoOption = resolutionSelect.querySelector('option[value="auto"]');
                    if (autoOption) {
                        autoOption.textContent = `Auto (${actualResolution}p)`;
                    }
                }
            });
        }

        // Download button
        downloadBtn.addEventListener("click", function() {
            if (currentFile) {
                const downloadUrl = "/direct/" + encodeFilePath(currentFile);
                const a = document.createElement("a");
                a.href = downloadUrl;
                a.download = currentFile.split("/").pop();
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }
        });

        // Metrics
        const metricsToggle = document.getElementById("metricsToggle");
        const metricsPanel = document.getElementById("metricsPanel");
        let metricsInterval = null;

        metricsToggle.addEventListener("click", function() {
            this.classList.toggle("active");
            metricsPanel.classList.toggle("active");

            if (metricsPanel.classList.contains("active")) {
                fetchMetrics();
                metricsInterval = setInterval(fetchMetrics, 2000);
            } else {
                if (metricsInterval) {
                    clearInterval(metricsInterval);
                    metricsInterval = null;
                }
            }
        });

        // Preset order for position calculation
        const PRESETS = ['ultrafast', 'superfast', 'veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow'];

        async function fetchMetrics() {
            try {
                const response = await fetch("/transcode/metrics");
                if (!response.ok) return;

                const data = await response.json();

                const formatRatio = (ratio) => ratio ? ratio.toFixed(1) + "%" : "-";
                const getRatioClass = (ratio) => {
                    if (!ratio) return "";
                    if (ratio >= 70 && ratio <= 80) return "good";  // Target range
                    if (ratio < 70) return "good";  // Below target is fine
                    if (ratio < 90) return "warning";
                    return "bad";
                };

                // Update adaptive preset display
                if (data.adaptive_preset) {
                    const preset = data.adaptive_preset;
                    document.getElementById("metricPreset").textContent = preset.current_preset;

                    // Position marker on preset bar (0-100%)
                    const presetIndex = PRESETS.indexOf(preset.current_preset);
                    const presetPosition = presetIndex >= 0 ? (presetIndex / (PRESETS.length - 1)) * 100 : 50;
                    document.getElementById("presetBar").style.left = presetPosition + "%";

                    // Update adjustment counts (‚ñ≤ = quality up, ‚ñº = quality down)
                    document.getElementById("presetAdjustUp").innerHTML = "&#9650; " + (preset.adjustments_up || 0);
                    document.getElementById("presetAdjustDown").innerHTML = "&#9660; " + (preset.adjustments_down || 0);
                }

                // Update adaptive CRF display
                if (data.adaptive_crf) {
                    const crf = data.adaptive_crf;
                    document.getElementById("metricCRF").textContent = "+" + (crf.crf_offset || 0);

                    // Position marker on CRF bar (0-100%, where 0=+0, 100=+7)
                    const crfPosition = ((crf.crf_offset || 0) / 7) * 100;
                    document.getElementById("crfBar").style.left = crfPosition + "%";

                    // Update adjustment counts (‚ñ≤ = quality up = CRF decreased, ‚ñº = quality down = CRF increased)
                    document.getElementById("crfAdjustDown").innerHTML = "&#9650; " + (crf.decreases || 0);
                    document.getElementById("crfAdjustUp").innerHTML = "&#9660; " + (crf.increases || 0);
                }

                // Update ratio gauge
                const avgRatio = data.transcode_ratio_avg || 0;
                const ratioNeedle = document.getElementById("ratioNeedle");
                const ratioValue = document.getElementById("ratioValue");

                // Clamp ratio to 0-100% for display
                const needlePos = Math.min(100, Math.max(0, avgRatio));
                ratioNeedle.style.left = needlePos + "%";

                ratioValue.textContent = formatRatio(avgRatio);
                ratioValue.className = "ratio-value " + getRatioClass(avgRatio);

                // Update performance metrics
                document.getElementById("metricRatioAvg").textContent = formatRatio(data.transcode_ratio_avg);
                document.getElementById("metricRatioAvg").className = "metric-value " + getRatioClass(data.transcode_ratio_avg);

                document.getElementById("metricRatioLast").textContent = formatRatio(data.transcode_ratio_last);
                document.getElementById("metricRatioLast").className = "metric-value " + getRatioClass(data.transcode_ratio_last);

                document.getElementById("metricRatioMin").textContent = formatRatio(data.transcode_ratio_min);
                document.getElementById("metricRatioMin").className = "metric-value good";

                document.getElementById("metricRatioMax").textContent = formatRatio(data.transcode_ratio_max);
                document.getElementById("metricRatioMax").className = "metric-value " + getRatioClass(data.transcode_ratio_max);

                document.getElementById("metricCacheHit").textContent = data.cache_hit_rate ? data.cache_hit_rate.toFixed(1) + "%" : "-";
                document.getElementById("metricCacheHit").className = "metric-value " + (data.cache_hit_rate > 50 ? "good" : "");

                document.getElementById("metricSegments").textContent = data.total_segments || 0;

                // Update codec info
                document.getElementById("metricVideoCodec").textContent = data.video_codec ? data.video_codec.toUpperCase() : "-";
                document.getElementById("metricAudioCodec").textContent = data.audio_codec ? data.audio_codec.toUpperCase() : "-";

                // Update mode display
                updateModeDisplay();

            } catch (err) {}
        }

        // Handle URL hash routing
        function handleHashRoute() {
            const hash = window.location.hash;
            if (hash.startsWith("#/play/")) {
                const encodedPath = hash.substring(7);
                const filePath = decodeURIComponent(encodedPath);

                if (filePath) {
                    const lastSlash = filePath.lastIndexOf("/");
                    const directory = lastSlash > 0 ? filePath.substring(0, lastSlash) : "";
                    const fileName = lastSlash > 0 ? filePath.substring(lastSlash + 1) : filePath;

                    currentPath = directory;
                    switchToPlayerMode();
                    loadSidebarFiles(directory).then(() => {
                        setTimeout(() => {
                            playFile(filePath, fileName);
                        }, 100);
                    });
                }
            }
        }

        window.addEventListener("hashchange", handleHashRoute);
        window.addEventListener("popstate", () => {
            if (!window.location.hash.startsWith("#/play/") && isPlayerMode) {
                switchToBrowseMode();
            }
        });

        // Initial load
        if (window.location.hash.startsWith("#/play/")) {
            handleHashRoute();
        } else {
            loadBrowseView("");
        }

        // TEST: Double-click subtitle dropdown to test progress bar
        subtitleSelect.addEventListener('dblclick', function() {
            showSubtitleProgress("Test Track (Japanese)");
            setTimeout(() => hideSubtitleProgress(true), 5000);
        });
    </script>
</body>
</html>
